<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PULSE">
    <link rel="apple-touch-icon" href="https://img.icons8.com/fluency/192/dna-helix.png">

    <title>PULSE</title>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        body {
            background-color: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, sans-serif;
        }

        canvas {
            position: absolute;
            z-index: 1;
        }

        #ui {
            position: absolute;
            z-index: 10;
            text-align: center;
            pointer-events: none; /* Laisse passer les clics vers le canvas sauf sur le bouton */
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s;
        }

        h1 {
            color: white;
            font-weight: 200;
            letter-spacing: 10px;
            font-size: 40px;
            margin-bottom: 20px;
            opacity: 0.8;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        button {
            pointer-events: auto;
            background: transparent;
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }

        button:active {
            background: white;
            color: black;
            transform: scale(0.95);
        }

        #hint {
            position: absolute;
            bottom: 40px;
            color: rgba(255,255,255,0.3);
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 2s;
        }

    </style>
</head>
<body>

    <div id="ui">
        <h1>PULSE</h1>
        <button id="startBtn">Wake Up</button>
    </div>

    <div id="hint">TOUCH TO INTERACT • SHAKE TO AGITATE</div>

    <canvas id="canvas"></canvas>

    <script>
        // --- CONFIGURATION ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('ui');
        const hint = document.getElementById('hint');
        
        let width, height;
        let audioCtx;
        let isRunning = false;
        
        // Physique de la bulle
        const numPoints = 16; // Plus y'a de points, plus c'est lisse mais lourd
        const radius = 120;
        let points = [];
        let time = 0;
        
        // Gyroscope
        let tiltX = 0;
        let tiltY = 0;

        // Couleur dynamique
        let hue = 200;

        // --- SETUP AUDIO (Web Audio API) ---
        // On crée un synthé simple pour faire des sons "spatiaux"
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playTone(freq, volume) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            // Type d'onde : Sine est doux, Triangle est plus "jeu vidéo"
            osc.type = 'sine'; 
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            // Enveloppe de volume (Attack, Decay)
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5); // Longue résonance

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 1.5);
        }

        // --- SETUP VISUEL ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            initBlob();
        }
        window.addEventListener('resize', resize);

        class Point {
            constructor(angle) {
                this.angle = angle;
                this.baseX = width/2 + Math.cos(angle) * radius;
                this.baseY = height/2 + Math.sin(angle) * radius;
                this.x = this.baseX;
                this.y = this.baseY;
                this.vx = 0;
                this.vy = 0;
                // Masse virtuelle pour l'effet ressort
                this.mass = 2; 
                this.spring = 0.05; // Rigidité
                this.friction = 0.90; // Amortissement
            }

            update(mouseX, mouseY, isTouching) {
                // 1. Force de retour vers la forme originale (Cercle)
                // On déplace le centre du cercle selon le gyroscope
                let targetX = (width/2 + tiltX * 200) + Math.cos(this.angle + time * 0.05) * radius;
                let targetY = (height/2 + tiltY * 200) + Math.sin(this.angle + time * 0.05) * radius;

                // Ajout d'une oscillation "respiration"
                let breathe = Math.sin(time * 2) * 10;
                targetX += Math.cos(this.angle) * breathe;
                targetY += Math.sin(this.angle) * breathe;

                // Application ressort
                const ax = (targetX - this.x) * this.spring;
                const ay = (targetY - this.y) * this.spring;

                this.vx += ax;
                this.vy += ay;

                // 2. Interaction Souris/Doigt (Répulsion)
                if (isTouching) {
                    const dx = this.x - mouseX;
                    const dy = this.y - mouseY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 150) {
                        const force = (150 - dist) / 150;
                        const angleToMouse = Math.atan2(dy, dx);
                        // On pousse le point
                        this.vx += Math.cos(angleToMouse) * force * 20;
                        this.vy += Math.sin(angleToMouse) * force * 20;
                    }
                }

                // Physique
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        function initBlob() {
            points = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                points.push(new Point(angle));
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            // Efface avec trainée pour effet liquide
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            time += 0.02;
            hue = (hue + 0.2) % 360;

            // Update points logic
            points.forEach(p => p.update(touchX, touchY, isTouching));

            // DESSIN DU BLOB (Courbes de Bézier)
            ctx.beginPath();
            // On connecte les points
            // Astuce : pour que ce soit rond, on dessine des courbes quadratiques entre les milieux des segments
            
            // Calculer les points médians
            let xc1 = (points[0].x + points[numPoints-1].x) / 2;
            let yc1 = (points[0].y + points[numPoints-1].y) / 2;
            ctx.moveTo(xc1, yc1);

            for (let i = 0; i < numPoints; i++) {
                // Point actuel
                let p = points[i];
                // Point suivant
                let nextP = points[(i + 1) % numPoints];
                // Milieu
                let xc = (p.x + nextP.x) / 2;
                let yc = (p.y + nextP.y) / 2;
                
                ctx.quadraticCurveTo(p.x, p.y, xc, yc);
            }
            
            ctx.closePath();
            
            // Style Néon
            ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Remplissage semi-transparent
            ctx.fillStyle = `hsla(${hue}, 100%, 60%, 0.1)`;
            ctx.fill();

            // Glow
            ctx.shadowBlur = 30;
            ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;

            // Oeil central (Juste pour donner de la vie)
            const eyeX = (width/2 + tiltX * 220); // Suit un peu plus le tilt
            const eyeY = (height/2 + tiltY * 220);
            
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, 10 + Math.sin(time*5)*2, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.shadowBlur = 50;
            ctx.shadowColor = 'white';
            ctx.fill();

            // Reset shadow pour la prochaine frame
            ctx.shadowBlur = 0;

            requestAnimationFrame(animate);
        }

        // --- INPUTS ---
        let touchX = 0;
        let touchY = 0;
        let isTouching = false;

        document.getElementById('startBtn').addEventListener('click', async () => {
            initAudio();
            
            // Permission Gyro
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
            }
            window.addEventListener('deviceorientation', e => {
                if(e.gamma) tiltX = e.gamma / 45; // -1 à 1
                if(e.beta) tiltY = (e.beta - 45) / 45; // Centré quand on tient le tel un peu penché
            });

            ui.style.opacity = 0;
            setTimeout(() => ui.style.display = 'none', 1000);
            hint.style.opacity = 1;
            
            resize();
            animate();
            isRunning = true;
            
            // Son de bienvenue
            playTone(440, 0.2);
            setTimeout(() => playTone(660, 0.2), 200);
        });

        // Gestion Touch
        window.addEventListener('touchstart', e => {
            if(!isRunning) return;
            isTouching = true;
            touchX = e.touches[0].clientX;
            touchY = e.touches[0].clientY;
            
            // Son aléatoire basé sur la position Y (plus haut = plus aigu)
            // Gamme pentatonique simple pour que ça sonne toujours bien
            const scale = [261.6, 293.6, 329.6, 392.0, 440.0, 523.2];
            const noteIndex = Math.floor((1 - (touchY / height)) * scale.length);
            const freq = scale[Math.min(Math.max(noteIndex, 0), scale.length-1)];
            
            playTone(freq, 0.3);
            
            // Coup de boost visuel
            hue += 50; 
        });

        window.addEventListener('touchmove', e => {
            if(!isRunning) return;
            touchX = e.touches[0].clientX;
            touchY = e.touches[0].clientY;
        });

        window.addEventListener('touchend', () => {
            isTouching = false;
        });

    </script>
</body>
</html>